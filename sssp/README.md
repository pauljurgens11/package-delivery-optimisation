# Optimized Single-Source Shortest Paths (SSSP)

## Why Dijkstra Is Not Optimal

Classic Dijkstra:

- Maintains a global priority queue
- Requires sorting vertices by distance
- Time: O(m + n log n)

The paper’s key observation:

You do not need a full global ordering of vertices to compute distances — only local ordering inside small frontiers.

This algorithm avoids global sorting by:

- Processing vertices in distance bands
- Recursively refining only small subsets
- Replacing priority queues with bounded partial ordering

## High-Level Idea

Three core concepts:

1. Frontier set `S`

    A small set of complete vertices such that:

    Any unfinished shortest path must pass through one of them

    Instead of sorting all vertices, we only reason about paths from `S`.

2. Bounded Multi-Source Shortest Path (BMSSP)

    Given:

    - A frontier `S`
    - An upper bound `B`

    Compute:

    - All vertices with `d(v) < B` whose shortest path goes through `S`

    This replaces:

    - “Extract-min” from a global heap

    with:

    - “Process a bounded distance interval” (So instead of total ordering, we do range-based exploration).

3. Pivot Reduction (Key Optimization)

    Problem:

    - Frontier S may still be large

    Solution:

    - Run k Bellman-Ford–style relaxations
    - Identify pivot vertices:
      - Roots of large shortest-path subtrees
    - Keep only those pivots for recursion

    This reduces the active frontier size by a factor of k.

    Why pivots are enough?

    - If a vertex u ∈ S has a small subtree:
      - Everything reachable from it gets completed quickly
      - We don’t need to recurse from it
    - If u has a large subtree:
      - Many unfinished vertices depend on it
      - We keep it as a pivot

## Algorithm Parameters

We use:

```python
k = log^(1/3)(n)
t = log^(2/3)(n)
```

These balance:

- Recursion depth
- Work per level
- Frontier size

In Python, these can be approximated using integers.

## Simplified Algorithm Structure

Pseudocode generated by ChatGPT 5.2.

### Main Driver

```pseudocode
SSSP(s):
    initialize d[s] = 0, d[others] = ∞
    BMSSP(level = ceil(log n / t), B = ∞, S = {s})

```

### BMSSP(level, B, S)

```pseudocode
function BMSSP(level, B, S):

    if level == 0:
        return BaseCase(B, S)

    (P, W) = FindPivots(B, S)

    initialize bounded priority structure D
    insert all pivots P into D

    U = empty set

    while D not empty and |U| < k * 2^(level * t):

        (S_i, B_i) = D.pull_smallest(M = 2^((level-1) * t))

        (B_i', U_i) = BMSSP(level-1, B_i, S_i)

        add U_i to U

        relax outgoing edges of U_i
        insert newly reached vertices back into D

    finalize U with vertices from W
    return (new boundary B', U)
```

### Base Case (Small Dijkstra)

Instead of full Dijkstra, we run it only until `k` vertices are found. This avoids unnecessary heap operations.

```pseudocode
function BaseCase(B, {x}):

    run Dijkstra starting from x
    stop after k+1 vertices or distance >= B

    if ≤ k vertices found:
        return (B, all found vertices)
    else:
        return (max distance among first k vertices, those k vertices)
```

### Pivot Selection (FindPivots)

Purpose: reduce the frontier size before recursion

Effect:

- Either we already explored enough vertices
- Or we keep only a small set of “important” roots

```pseudocode
function FindPivots(B, S):

    W = S
    frontier = S

    repeat k times:
        relax edges from frontier
        add newly improved vertices to W
        update frontier

        if |W| > k * |S|:
            return (P = S, W)

    build shortest-path forest on W
    P = roots with subtree size ≥ k

    return (P, W)
```

## What We Optimize

- Avoid global sorting
- Replace heap operations with bounded pulls
- Reduce frontier size via pivot selection
- Use recursion depth ≈ log^(1/3) n
- Process each edge only O(log^(1/3) n) times

## What We Leave Out

The following are not implemented initially:

- Constant-degree graph transformation
- Strict comparison-addition model enforcement
- Exact block-based data structure from Lemma 3.3
- Path uniqueness tie-breaking machinery
- Worst-case optimal constants

These do not affect correctness for practical use.

## Expected Complexity

| Algorithm      | Time              |
| -------------- | ----------------- |
| Dijkstra       | O(n log n)        |
| This algorithm | ~O(n log^(2/3) n) |
